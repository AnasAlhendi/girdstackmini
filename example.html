<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>GridStack Minimal Example</title>
    <style>
      .grid-stack {
        width: 100%; max-width: 1000px; margin: 20px auto;min-height: 360px;
      }
      .grid-stack > .grid-stack-item { outline: 2px solid #000; }
      .grid-stack-item-content {
        background:#4b8cfb; color:#fff; display:flex; align-items:center; justify-content:center;
        border-radius:8px; font: 14px/1.2 system-ui, sans-serif;
      }
      body, html { margin:0; padding:0; }
      .controls { max-width: 1000px; margin: 10px auto; display: flex; gap: 8px; }
      button { padding: 6px 10px; }
    </style>
  </head>
  <body>
    <div class="controls">
      <label for="screenSelect">Screen:</label>
      <select id="screenSelect">
        <option disabled selected>Loading profiles…</option>
      </select>
      <button id="add">Add Widget</button>
      <button id="addHtmlWrap">Add HTML -> Button</button>
      <button id="addHtmlPre">Add Prebuilt Button HTML</button>
      <button id="move">Move/Resize B</button>
      <button id="remove">Remove A</button>
    </div>
    <div class="grid-stack" id="grid"></div>

    <script src="gridstack.js"></script>
    <script>
      // Init with basic options
      const grid = new GridStack('#grid', {
        columns: 12,
        rows: 12,
        margin: '8px',
        cellHeight: 80,
        debug: false,
      });

      // Optional: make cells square
      function setSquareCells() {
        const gridEl = document.getElementById('grid');
        const w = gridEl.clientWidth || gridEl.getBoundingClientRect().width;
        const cell = Math.max(10, Math.floor(w / 12));
        grid.setCellHeight(cell);
      }
      window.addEventListener('resize', setSquareCells);
      setSquareCells();

      // Load screen profiles from test.md and hook the dropdown
      const screenSelect = document.getElementById('screenSelect');
      const profiles = new Map();

      function applyProfile(p) {
        if (!p) return;
        grid.setColumns(p.columns);
        grid.setRows(p.rows);
        grid.setMargin(p.boxPadding);
        // apply edge padding on the grid container
        const gridEl = document.getElementById('grid');
        gridEl.style.padding = p.edgePadding;
        // recompute cell height to maintain square-ish cells unless user resizes
        setSquareCells();
      }

      function parseProfilesFromMarkdown(text) {
        // Expect repeating blocks like:
        // 22" … 1080 x 1920 (Portrait) zelos v2:
        // Grid: 12 x 25
        // Box padding: 29px
        // Edge padding: 29px
        const lines = text.split(/\r?\n/);
        const res = [];
        let current = null;
        const headerRe = /^\s*([^:]+?):\s*$/; // capture until trailing colon
        const gridRe = /^\s*Grid:\s*(\d+)\s*x\s*(\d+)\s*$/i;
        const boxPadRe = /^\s*Box\s*padding:\s*([0-9]+\s*px)\s*$/i;
        const edgePadRe = /^\s*Edge\s*padding:\s*([0-9]+\s*px)\s*$/i;
        for (const raw of lines) {
          const line = raw.trim();
          if (!line) continue;
          const hm = line.match(headerRe);
          if (hm) {
            // finalize previous
            if (current) res.push(current);
            const title = hm[1].trim();
            current = { title, columns: 12, rows: 12, boxPadding: '8px', edgePadding: '0px' };
            continue;
          }
          if (!current) continue;
          let m;
          if ((m = line.match(gridRe))) {
            current.columns = parseInt(m[1], 10);
            current.rows = parseInt(m[2], 10);
            continue;
          }
          if ((m = line.match(boxPadRe))) {
            current.boxPadding = m[1].replace(/\s+/g, '');
            continue;
          }
          if ((m = line.match(edgePadRe))) {
            current.edgePadding = m[1].replace(/\s+/g, '');
            continue;
          }
        }
        if (current) res.push(current);
        return res;
      }

      function nameFromTitle(title) {
        const t = String(title || '').toLowerCase();
        if (t.includes('zelos')) return 'Zelos';
        if (t.includes('mitra')) return 'Mitra';
        if (t.includes('mirta')) return 'Mirta';
        // fallback: first alpha word capitalized
        const m = (title || '').match(/[A-Za-z]+/);
        return m ? (m[0].charAt(0).toUpperCase() + m[0].slice(1)) : (title || 'Profile');
      }

      function stripPx(v) {
        return String(v || '').replace(/px$/i, '');
      }

      function profileValueString(p) {
        const nm = nameFromTitle(p.title);
        // As requested: value like
        // "Zelos heig 12 width 22 boxpadding 29 edaging padding 29"
        return `${nm} heig ${p.rows} width ${p.columns} boxpadding ${stripPx(p.boxPadding)} edaging padding ${stripPx(p.edgePadding)}`;
      }

      async function loadProfiles() {
        try {
          const resp = await fetch('test.md');
          const txt = await resp.text();
          const list = parseProfilesFromMarkdown(txt);
          // clear all options
          while (screenSelect.options.length) screenSelect.remove(0);
          list.forEach((p, idx) => {
            const opt = document.createElement('option');
            // Use requested human-readable value format
            const val = profileValueString(p);
            opt.value = val;
            opt.textContent = p.title;
            screenSelect.appendChild(opt);
            profiles.set(val, p);
          });
          // auto-select first parsed profile if available
          if (list.length) {
            const firstVal = profileValueString(list[0]);
            screenSelect.value = firstVal;
            applyProfile(list[0]);
          } else {
            // Fallback: show placeholder when none found
            const opt = document.createElement('option');
            opt.disabled = true;
            opt.selected = true;
            opt.textContent = 'No profiles found';
            screenSelect.appendChild(opt);
          }
        } catch (e) {
          // If fetch fails (e.g., opened as file://), keep defaults
          console.warn('Unable to load test.md; using defaults', e);
          while (screenSelect.options.length) screenSelect.remove(0);
          const opt = document.createElement('option');
          opt.disabled = true;
          opt.selected = true;
          opt.textContent = 'Failed to load profiles';
          screenSelect.appendChild(opt);
        }
      }

      screenSelect.addEventListener('change', () => {
        const key = screenSelect.value;
        const p = profiles.get(key);
        applyProfile(p);
      });

      loadProfiles();

      // Add initial 1x1 widgets on first row
      const a = grid.addWidget({ x: 0, y: 0, w: 1, h: 1, content: 'A' });
      const b = grid.addWidget({ x: 1, y: 0, w: 1, h: 1, content: 'B' });
      b.id = 'item-b';

      // Wire up controls
      document.getElementById('add').addEventListener('click', () => {
        const count = document.querySelectorAll('.grid-stack-item').length;
        grid.addWidget({ w: 1, h: 1, content: 'New ' + count });
      });

      // Add HTML -> Button (element becomes the item) and log result
      document.getElementById('addHtmlWrap').addEventListener('click', () => {
        const html = '<button style="background:#444;color:#fff;border:0;border-radius:8px;">B</button>';
        const el = grid.htmlAsItem(html);

      });

      // Add prebuilt grid item HTML directly as an item and log result
      document.getElementById('addHtmlPre').addEventListener('click', () => {
        const pre = '<button class="grid-stack-item" gs-x="0" gs-y="2" gs-w="3" gs-h="2" style="background:#2c6bf2;color:#fff;border:0;border-radius:8px;outline:3px solid #000;font-weight:700;">PREBUILT</button>';
        const el = grid.htmlAsItem(pre);

      });

      document.getElementById('move').addEventListener('click', () => {
        grid.updateWidget('#item-b', { x: 6, y: 1, w: 5, h: 2 });
      });

      document.getElementById('remove').addEventListener('click', () => {
        grid.removeWidget(a);
      });
    </script>
  </body>
  </html>
