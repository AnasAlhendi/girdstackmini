<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>GridStack Minimal Example</title>
    <style>
      .grid-stack {
        width: 100%; max-width: 1000px; margin: 20px auto;min-height: 360px;
      }
      .grid-stack > .grid-stack-item { outline: 2px solid #000; }
      .grid-stack-item-content {
        background:#4b8cfb; color:#fff; display:flex; align-items:center; justify-content:center;
        border-radius:8px; font: 14px/1.2 system-ui, sans-serif;
      }
      body, html { margin:0; padding:0; }
      .controls { max-width: 1000px; margin: 10px auto; display: flex; gap: 8px; }
      button { padding: 6px 10px; }
    </style>
  </head>
  <body>
    <div class="controls">
      <label for="screenSelect">Screen:</label>
      <select id="screenSelect">
        <option value="__screed__">screed</option>
        <option disabled selected>Loading profiles…</option>
      </select>
      <button id="add">Add Widget</button>
      <button id="addHtmlWrap">Add HTML -> Button</button>
      <button id="addHtmlPre">Add Prebuilt Button HTML</button>
      <button id="move">Move/Resize B</button>
      <button id="remove">Remove A</button>
    </div>
    <div class="grid-stack" id="grid"></div>

    <script src="gridstack.js"></script>
    <script>
      // Init with basic options
      const grid = new GridStack('#grid', {
        columns: 12,
        rows: 12,
        margin: '8px',
        cellHeight: 80,
        debug: false,
      });

      // Optional: make cells square
      function setSquareCells() {
        const gridEl = document.getElementById('grid');
        const w = gridEl.clientWidth || gridEl.getBoundingClientRect().width;
        const cell = Math.max(10, Math.floor(w / 12));
        grid.setCellHeight(cell);
      }
      window.addEventListener('resize', setSquareCells);
      setSquareCells();

      // Load screen profiles from test.md and hook the dropdown
      const screenSelect = document.getElementById('screenSelect');
      const profiles = new Map();

      function applyProfile(p) {
        if (!p) return;
        grid.setColumns(p.columns);
        grid.setRows(p.rows);
        grid.setMargin(p.boxPadding);
        // apply edge padding on the grid container
        const gridEl = document.getElementById('grid');
        gridEl.style.padding = p.edgePadding;
        // recompute cell height to maintain square-ish cells unless user resizes
        setSquareCells();
      }

      function parseProfilesFromMarkdown(text) {
        // Expect repeating blocks like:
        // 22" … 1080 x 1920 (Portrait) zelos v2:
        // Grid: 12 x 25
        // Box padding: 29px
        // Edge padding: 29px
        const lines = text.split(/\r?\n/);
        const res = [];
        let current = null;
        const headerRe = /^\s*([^:]+?):\s*$/; // capture until trailing colon
        const gridRe = /^\s*Grid:\s*(\d+)\s*x\s*(\d+)\s*$/i;
        const boxPadRe = /^\s*Box\s*padding:\s*([0-9]+\s*px)\s*$/i;
        const edgePadRe = /^\s*Edge\s*padding:\s*([0-9]+\s*px)\s*$/i;
        for (const raw of lines) {
          const line = raw.trim();
          if (!line) continue;
          const hm = line.match(headerRe);
          if (hm) {
            // finalize previous
            if (current) res.push(current);
            const title = hm[1].trim();
            current = { title, columns: 12, rows: 12, boxPadding: '8px', edgePadding: '0px' };
            continue;
          }
          if (!current) continue;
          let m;
          if ((m = line.match(gridRe))) {
            current.columns = parseInt(m[1], 10);
            current.rows = parseInt(m[2], 10);
            continue;
          }
          if ((m = line.match(boxPadRe))) {
            current.boxPadding = m[1].replace(/\s+/g, '');
            continue;
          }
          if ((m = line.match(edgePadRe))) {
            current.edgePadding = m[1].replace(/\s+/g, '');
            continue;
          }
        }
        if (current) res.push(current);
        return res;
      }

      async function loadProfiles() {
        try {
          const resp = await fetch('test.md');
          const txt = await resp.text();
          const list = parseProfilesFromMarkdown(txt);
          // populate dropdown (keep the first static 'screed' option)
          // clear any non-static options
          while (screenSelect.options.length > 1) screenSelect.remove(1);
          list.forEach((p, idx) => {
            const opt = document.createElement('option');
            const key = `md-${idx}`;
            opt.value = key;
            opt.textContent = p.title;
            screenSelect.appendChild(opt);
            profiles.set(key, p);
          });
          // auto-select first parsed profile if available
          if (list.length) {
            screenSelect.value = 'md-0';
            applyProfile(list[0]);
          } else {
            // Fallback to default grid setup
            screenSelect.value = '__screed__';
          }
        } catch (e) {
          // If fetch fails (e.g., opened as file://), keep defaults
          console.warn('Unable to load test.md; using defaults', e);
          // prune loading placeholder
          while (screenSelect.options.length > 1) screenSelect.remove(1);
          screenSelect.value = '__screed__';
        }
      }

      screenSelect.addEventListener('change', () => {
        const key = screenSelect.value;
        if (key === '__screed__') {
          // basic neutral defaults
          applyProfile({ columns: 12, rows: 12, boxPadding: '8px', edgePadding: '0px' });
        } else {
          const p = profiles.get(key);
          applyProfile(p);
        }
      });

      loadProfiles();

      // Add initial 1x1 widgets on first row
      const a = grid.addWidget({ x: 0, y: 0, w: 1, h: 1, content: 'A' });
      const b = grid.addWidget({ x: 1, y: 0, w: 1, h: 1, content: 'B' });
      b.id = 'item-b';

      // Wire up controls
      document.getElementById('add').addEventListener('click', () => {
        const count = document.querySelectorAll('.grid-stack-item').length;
        grid.addWidget({ w: 1, h: 1, content: 'New ' + count });
      });

      // Add HTML -> Button (element becomes the item) and log result
      document.getElementById('addHtmlWrap').addEventListener('click', () => {
        const html = '<button style="background:#444;color:#fff;border:0;border-radius:8px;">B</button>';
        const el = grid.htmlAsItem(html);

      });

      // Add prebuilt grid item HTML directly as an item and log result
      document.getElementById('addHtmlPre').addEventListener('click', () => {
        const pre = '<button class="grid-stack-item" gs-x="0" gs-y="2" gs-w="3" gs-h="2" style="background:#2c6bf2;color:#fff;border:0;border-radius:8px;outline:3px solid #000;font-weight:700;">PREBUILT</button>';
        const el = grid.htmlAsItem(pre);

      });

      document.getElementById('move').addEventListener('click', () => {
        grid.updateWidget('#item-b', { x: 6, y: 1, w: 5, h: 2 });
      });

      document.getElementById('remove').addEventListener('click', () => {
        grid.removeWidget(a);
      });
    </script>
  </body>
  </html>
